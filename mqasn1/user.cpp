//   NOTE: this is a machine generated file--editing not recommended
//
// user.cpp - class member functions for ASN.1 module QvVNM
//
//   This file was generated by snacc on Wed Jul 16 17:19:49 2014
//   UBC snacc written by Mike Sample


#include "user.h"

namespace SNACC{
//------------------------------------------------------------------------------
// value defs


//------------------------------------------------------------------------------
// class member definitions:

void AsnUserLoginReqeust::Init(void)
{
}


int AsnUserLoginReqeust::checkConstraints(ConstraintFailList* pConstraintFails) const{
	name.checkConstraints(pConstraintFails);

	password.checkConstraints(pConstraintFails);

	return 0;
}


void AsnUserLoginReqeust::Clear()
{
}

AsnUserLoginReqeust::AsnUserLoginReqeust(const AsnUserLoginReqeust &that)
{
   Init();
   *this = that;
}
AsnType *AsnUserLoginReqeust::Clone() const
{
  return new AsnUserLoginReqeust(*this);
}

AsnUserLoginReqeust &AsnUserLoginReqeust::operator = (const AsnUserLoginReqeust &that)
{
  if (this != &that)
  {
    Clear();
    name = that.name;
    password = that.password;
  }

  return *this;
}

AsnLen
AsnUserLoginReqeust::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = password.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = name.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

  return totalLen;
} // AsnUserLoginReqeust::BEncContent


void AsnUserLoginReqeust::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" AsnUserLoginReqeust::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    name.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    password.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // AsnUserLoginReqeust::BDecContent

AsnLen AsnUserLoginReqeust::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void AsnUserLoginReqeust::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" AsnUserLoginReqeust::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void AsnUserLoginReqeust::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "name ";
	name.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "password ";
	password.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of AsnUserLoginReqeust::Print()

void AsnUserLoginReqeust::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    name.PrintXML(os, "name");

    password.PrintXML(os, "password");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // AsnUserLoginReqeust::PrintXML


void AsnUserLoginResponse::Init(void)
{
}


int AsnUserLoginResponse::checkConstraints(ConstraintFailList* pConstraintFails) const{
	success.checkConstraints(pConstraintFails);

	error.checkConstraints(pConstraintFails);

	counter.checkConstraints(pConstraintFails);

	return 0;
}


void AsnUserLoginResponse::Clear()
{
}

AsnUserLoginResponse::AsnUserLoginResponse(const AsnUserLoginResponse &that)
{
   Init();
   *this = that;
}
AsnType *AsnUserLoginResponse::Clone() const
{
  return new AsnUserLoginResponse(*this);
}

AsnUserLoginResponse &AsnUserLoginResponse::operator = (const AsnUserLoginResponse &that)
{
  if (this != &that)
  {
    Clear();
    success = that.success;
    error = that.error;
    counter = that.counter;
  }

  return *this;
}

AsnLen
AsnUserLoginResponse::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = counter.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = error.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = success.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, UNIV, PRIM, BOOLEAN_TAG_CODE);
    totalLen += l;

  return totalLen;
} // AsnUserLoginResponse::BEncContent


void AsnUserLoginResponse::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" AsnUserLoginResponse::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, BOOLEAN_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    success.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    error.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    counter.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // AsnUserLoginResponse::BDecContent

AsnLen AsnUserLoginResponse::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void AsnUserLoginResponse::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" AsnUserLoginResponse::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void AsnUserLoginResponse::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "success ";
	success.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "error ";
	error.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "counter ";
	counter.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of AsnUserLoginResponse::Print()

void AsnUserLoginResponse::PrintXML (std::ostream &os, 
                   const char *lpszTitle) const
{
  if (lpszTitle)
  {
     os << "<" << lpszTitle;
     if (typeName() && strlen(typeName()))
     {
        os << " typeName=\"" << typeName() << "\"";
     }
  }
  else
  {
     os << "<NONE";
  }
  if (typeName() && strlen(typeName()))
  {
     if (typeName() && strlen(typeName()))
     {
        os << "<" << typeName();
     }
  }
 os << " type=\"SEQUENCE\">" << std::endl;
    success.PrintXML(os, "success");

    error.PrintXML(os, "error");

    counter.PrintXML(os, "counter");

  if (lpszTitle)
  {
     os << "</" << lpszTitle << ">" << std::endl;
  }
  else
     if (typeName() && strlen(typeName()))
     {
        os << "</" << typeName() << ">" << std::endl;
     }
} // AsnUserLoginResponse::PrintXML


#ifndef NO_NAMESPACE
} // namespace close
#endif
